import { authClearMessage, authReset, login, logout, me } from "@/redux/slices/authSlice";
import { AppDispatch, RootState } from "@/redux/store";
import { createContext, useContext, useEffect, useRef } from "react";
import { useDispatch, useSelector } from "react-redux";

//*************************************************************
//* Tipagens para o contexto
//*************************************************************
function useAuthProvider() {
  const dispatch = useDispatch<AppDispatch>();
  const { authResponse, loggedUser, status: authStatus, message: authMessage, initializing: authInitializing } = useSelector((state: RootState) => state.auth);
  const lastCallRef = useRef(0);

  //?????????????????????????????????????????????????????????????????????????????????
  //? Metodos do contexto
  //?????????????????????????????????????????????????????????????????????????????????
  function signIn(data: { email: string, password: string, rememberMe: boolean }) {
    dispatch(login(data));
  }

  function signOut() {
    dispatch(logout());
  }

  //?????????????????????????????????????????????????????????????????????????????????
  //? useEffects
  //?????????????????????????????????????????????????????????????????????????????????
  useEffect(() => { //tenta buscar 'me', se cookies ainda forem validos, já vai 'autenticar'
    dispatch(me());
  }, [dispatch]);

  useEffect(() => {
    if (authStatus === 'failed') {
      if (!authMessage && loggedUser) //authMessage vazia, é porque o token expirou e se loggerUser preenchido é pq tem sessão, assim forma a ir para login
        dispatch(authReset());

      const timer = setTimeout(() => dispatch(authClearMessage()), 3000);
      return () => clearTimeout(timer);
    }
  }, [authStatus, loggedUser, dispatch]);

  useEffect(() => {
    function handleFocus() {
      if (!loggedUser) //se não estiver logado não precisa testar
        return;

      const now = Date.now(); //data atual para comparar se tempo de nova checagem passou
      if (now - lastCallRef.current <= 20_000) //20 seconds
        return;

      lastCallRef.current = now;
      dispatch(me());
    }
    window.addEventListener("focus", handleFocus);
    return () => window.removeEventListener("focus", handleFocus);
  }, [dispatch, loggedUser]);

  //?????????????????????????????????????????????????????????????????????????????????
  //? Derivados do estado
  //?????????????????????????????????????????????????????????????????????????????????
  const isAuthenticated = !!loggedUser;
  const isLoading = authStatus === 'loading' || authInitializing;
  const error = authStatus === 'failed';
  const message = authMessage;

  return {
    isAuthenticated,
    isLoading,
    error,
    message,
    userData: loggedUser,
    origin: authResponse?.origin,
    signIn,
    signOut
  }
}
export type AuthContextType = ReturnType<typeof useAuthProvider>;

//*************************************************************
//* Criando o contexto, com base no tipo acima
//*************************************************************
//! mantem privado pra forçar o uso de useAuthContext
const AuthContext = createContext<AuthContextType | undefined>(undefined);

//*************************************************************
//* Componente Provider do contexto (onde são iniciadas as 
//* variáveis de estado e as funções que serão passadas no value)
//* E então passadas no value para serem usadas pelos componentes filhos
//*************************************************************
export function AuthProvider({ children }: { children: React.ReactNode }) {
  const auth = useAuthProvider();
  return (
    <AuthContext.Provider value={auth} >
      {children}
    </AuthContext.Provider>
  );
}

//*************************************************************
//* Wrappers para o contexto, de modo que não precise ser chamado
//* useContext([name]Context) diretamente. Mas sim 'use' abaixo
//* que já faz a verificação de undefined e retorna o contexto
//*************************************************************
export function useAuthContext() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
}

//! por que não usar os loadings dos slices:
//! como são dois loadings distintos, de depois processos interdependentes, ocorre de
//! ao processar o authSlice ele terminar o loading e o userSlice ainda não iniciou
//! isso faz as paginas de login e home darem o flicker pois efetivamente ele está
//! num estado intermediario e ainda não autenticado mas sem loading (pegou o jwt mas
//! ainda nao processou o 'me')