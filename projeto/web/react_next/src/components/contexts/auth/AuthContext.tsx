import LoggedUser from "@/models/LoggedUser";
import { createContext, useContext, useEffect, useRef, useState } from "react";
import fetchMe from "./functions/fetchMe";
import signIn, { signInParams } from "./functions/signIn";
import signOut from "./functions/signOut";

//*************************************************************
//* Tipagens para o contexto
//*************************************************************
function useAuthProvider() {
  const [loggedUser, setLoggedUser] = useState<LoggedUser | null>(null);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const lastCallRef = useRef(0);
  const isAuthenticated = !!loggedUser;

  //?????????????????????????????????????????????????????????????????????????????????
  //? Metodos do contexto
  //?????????????????????????????????????????????????????????????????????????????????
  async function signInHandler(data: { email: string, password: string, rememberMe: boolean }) {
    if (!data.email || !data.password || data.rememberMe === null) {
      setErrorMessage("Invalid login data!");
      return;
    }
    await authHandler(data);
  }

  async function signOutHandler() {
    await signOut();
    setLoggedUser(null);
  }

  //?????????????????????????????????????????????????????????????????????????????????
  //? internal methods
  //?????????????????????????????????????????????????????????????????????????????????
  const authHandler = async (params?: signInParams, setLoad = true) => {
    if (setLoad)
      setIsLoading(true);

    let data: LoggedUser | string;
    if (params)
      data = await signIn(params);
    else
      data = await fetchMe();

    if (typeof data === 'string') {
      setErrorMessage(data);
      setLoggedUser(null);
    } else {
      setLoggedUser(data);
    }

    if (setLoad)
      setIsLoading(false);
  }

  const handleFocus = async () => { //!para verificar se usuário ainda está logado (caso logout feito em outra aba)
    if (!loggedUser) //se não estiver logado não precisa testar
      return;

    const now = Date.now(); //data atual para comparar se tempo de nova checagem passou
    if (now - lastCallRef.current <= 60_000) //60 seconds
      return;

    lastCallRef.current = now;
    await authHandler(undefined, false);
  }
  //?????????????????????????????????????????????????????????????????????????????????
  //? useEffects
  //?????????????????????????????????????????????????????????????????????????????????
  useEffect(() => { //!tenta buscar 'me', se cookies ainda forem validos, já vai 'autenticar'
    authHandler();
  }, []);

  useEffect(() => { //!limpeza da mensagem de erro
    const timer = setTimeout(() => setErrorMessage(''), 3000);
    return () => clearTimeout(timer);
  }, [errorMessage]);

  useEffect(() => { //!ativar o evento para checage assim que usuário logar
    if (loggedUser)
      window.addEventListener("focus", handleFocus);
    return () => window.removeEventListener("focus", handleFocus);
  }, [loggedUser]);

  //?????????????????????????????????????????????????????????????????????????????????
  //? Derivados do estado
  //?????????????????????????????????????????????????????????????????????????????????

  return {
    isAuthenticated,
    isLoading,
    errorMessage,
    userData: loggedUser,
    signIn: signInHandler,
    signOut: signOutHandler
  }
}
export type AuthContextType = ReturnType<typeof useAuthProvider>;

//*************************************************************
//* Criando o contexto, com base no tipo acima
//*************************************************************
//! mantem privado pra forçar o uso de useAuthContext
const AuthContext = createContext<AuthContextType | undefined>(undefined);

//*************************************************************
//* Componente Provider do contexto (onde são iniciadas as 
//* variáveis de estado e as funções que serão passadas no value)
//* E então passadas no value para serem usadas pelos componentes filhos
//*************************************************************
export function AuthProvider({ children }: { children: React.ReactNode }) {
  const auth = useAuthProvider();
  return (
    <AuthContext.Provider value={auth} >
      {children}
    </AuthContext.Provider>
  );
}

//*************************************************************
//* Wrappers para o contexto, de modo que não precise ser chamado
//* useContext([name]Context) diretamente. Mas sim 'use' abaixo
//* que já faz a verificação de undefined e retorna o contexto
//*************************************************************
export function useAuthContext() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
}

//! por que não usar os loadings dos slices:
//! como são dois loadings distintos, de depois processos interdependentes, ocorre de
//! ao processar o authSlice ele terminar o loading e o userSlice ainda não iniciou
//! isso faz as paginas de login e home darem o flicker pois efetivamente ele está
//! num estado intermediario e ainda não autenticado mas sem loading (pegou o jwt mas
//! ainda nao processou o 'me')